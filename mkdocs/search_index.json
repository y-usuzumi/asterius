{
    "docs": [
        {
            "location": "/",
            "text": "asterius\n is a Haskell to WebAssembly compiler. The project is pre-alpha and in active development, still takes time before an initial example works.\n\n\nThe \nhaddock\n documentation is available \nhere\n.\n\n\nSponsors\n\n\nAsterius is maintained by \nTweag I/O\n.\n\n\nHave questions? Need help? Tweet at \n@tweagio\n.",
            "title": "Home"
        },
        {
            "location": "/#sponsors",
            "text": "Asterius is maintained by  Tweag I/O .  Have questions? Need help? Tweet at  @tweagio .",
            "title": "Sponsors"
        },
        {
            "location": "/building/",
            "text": "asterius\n is tested on Linux x64 and Windows x64. macOS x64 may also work.\n\n\ntl;dr: See \n.circleci/config.yml\n for CircleCI config, \nappveyor.yml\n for AppVeyor config.\n\n\nBuilding custom \nghc\n\n\nasterius\n requires a custom \nghc\n which:\n\n\n\n\nUses \nghc-head\n instead of a release version. It forces us to keep an eye on upstream changes. The \nmaster\n branch of \nghc\n may introduce breaking commits, so for safety you should choose the specific \nghc\n commit as indicated in the \nNIXPKGS_REV\n revision of the CircleCI config file, details below.\n\n\nDisables \nTABLES_NEXT_TO_CODE\n. It's impossible to attach executable code to an info table on the WebAssembly platform.\n\n\nUses \ninteger-simple\n instead of \ninteger-gmp\n. Porting \ninteger-gmp\n to WebAssembly requires extra work and is not currently scheduled.\n\n\n\n\nThe building guide of \nghc\n can be found \nhere\n. Add the following lines to \nmk/build.mk\n:\n\n\nGhcEnableTablesNextToCode = NO\nINTEGER_LIBRARY           = integer-simple\n\n\n\n\nIn addition to your own build configs.\n\n\nOn Linux/Windows, a prebuilt \nghc\n tarball is provided. It's already included in \nstack.yaml\n.\n\n\nExtra dependencies\n\n\nBesides the custom \nghc\n, these dependencies are also required:\n\n\n\n\ncmake\n/\nmake\n/\ng++\n: For building in-tree \nbinaryen\n\n\nautoconf\n: For booting \nghc-prim\n/\nbase\n\n\nnodejs\n: For running tests\n\n\nstack\n\n\n\n\nBuilding \nasterius\n\n\nstack build asterius\n. That's it. If you are using \nnix\n, make sure to add \n--system-ghc\n when invoking \nstack\n.\n\n\nSet \nMAKEFLAGS=-j8\n to pass flags to \nmake\n for parallel building of \nbinaryen\n. Run \nstack exec ahc-boot\n to test if booting works.",
            "title": "Building guide"
        },
        {
            "location": "/building/#building-custom-ghc",
            "text": "asterius  requires a custom  ghc  which:   Uses  ghc-head  instead of a release version. It forces us to keep an eye on upstream changes. The  master  branch of  ghc  may introduce breaking commits, so for safety you should choose the specific  ghc  commit as indicated in the  NIXPKGS_REV  revision of the CircleCI config file, details below.  Disables  TABLES_NEXT_TO_CODE . It's impossible to attach executable code to an info table on the WebAssembly platform.  Uses  integer-simple  instead of  integer-gmp . Porting  integer-gmp  to WebAssembly requires extra work and is not currently scheduled.   The building guide of  ghc  can be found  here . Add the following lines to  mk/build.mk :  GhcEnableTablesNextToCode = NO\nINTEGER_LIBRARY           = integer-simple  In addition to your own build configs.  On Linux/Windows, a prebuilt  ghc  tarball is provided. It's already included in  stack.yaml .",
            "title": "Building custom ghc"
        },
        {
            "location": "/building/#extra-dependencies",
            "text": "Besides the custom  ghc , these dependencies are also required:   cmake / make / g++ : For building in-tree  binaryen  autoconf : For booting  ghc-prim / base  nodejs : For running tests  stack",
            "title": "Extra dependencies"
        },
        {
            "location": "/building/#building-asterius",
            "text": "stack build asterius . That's it. If you are using  nix , make sure to add  --system-ghc  when invoking  stack .  Set  MAKEFLAGS=-j8  to pass flags to  make  for parallel building of  binaryen . Run  stack exec ahc-boot  to test if booting works.",
            "title": "Building asterius"
        },
        {
            "location": "/architecture/",
            "text": "High-level architecture\n\n\nThe \nasterius\n project is hosted at \nGitHub\n. The monorepo contains several packages:\n\n\n\n\nasterius\n. This is the central package of the \nasterius\n compiler.\n\n\nbinaryen\n. It contains the latest source code of the C++ library \nbinaryen\n in tree, and provides complete raw bindings to its \nC API\n.\n\n\nghc-toolkit\n. It provides a framework for implementing Haskell-to-X compilers by retrieving \nghc\n's various types of in-memory intermediate representations. It also contains the latest source code of \nghc-prim\n/\ninteger-gmp\n/\ninteger-simple\n/\nbase\n in tree.\n\n\n\n\nThe \nasterius\n package provides an \nahc\n executable which is a drop-in replacement of \nghc\n to be used with \nSetup configure\n. \nahc\n redirects all arguments to the real \nghc\n most of the time, but when it's invoked with the \n--make\n major mode, it invokes \nghc\n with its frontend plugin. This is inspired by Edward Yang's \nHow to integrate GHC API programs with Cabal\n.\n\n\nBased on \nghc-toolkit\n, \nasterius\n implements a \nghc\n frontend plugin\n which translates \nCmm\n to \nbinaryen\n IR. The serialized \nbinaryen\n IR can then be loaded and linked to a WebAssembly binary (not implemented yet). The normal compilation pipeline which generates native machine code is not affected.\n\n\nAbout \"booting\"\n\n\nIn order for \nasterius\n to support non-trivial Haskell programs (that is, at least most things in \nPrelude\n), it needs to run the compilation process for \nbase\n and its dependent packages. This process is known as \"booting\".\n\n\nThe \nasterius\n package provides an \nahc-boot\n test suite which tests booting by compiling the wired-in packages provided by \nghc-toolkit\n and using \nahc\n to replace \nghc\n when configuring. This is inspired by Joachim Breitner's \nveggies\n.",
            "title": "Project architecture"
        },
        {
            "location": "/architecture/#high-level-architecture",
            "text": "The  asterius  project is hosted at  GitHub . The monorepo contains several packages:   asterius . This is the central package of the  asterius  compiler.  binaryen . It contains the latest source code of the C++ library  binaryen  in tree, and provides complete raw bindings to its  C API .  ghc-toolkit . It provides a framework for implementing Haskell-to-X compilers by retrieving  ghc 's various types of in-memory intermediate representations. It also contains the latest source code of  ghc-prim / integer-gmp / integer-simple / base  in tree.   The  asterius  package provides an  ahc  executable which is a drop-in replacement of  ghc  to be used with  Setup configure .  ahc  redirects all arguments to the real  ghc  most of the time, but when it's invoked with the  --make  major mode, it invokes  ghc  with its frontend plugin. This is inspired by Edward Yang's  How to integrate GHC API programs with Cabal .  Based on  ghc-toolkit ,  asterius  implements a  ghc  frontend plugin  which translates  Cmm  to  binaryen  IR. The serialized  binaryen  IR can then be loaded and linked to a WebAssembly binary (not implemented yet). The normal compilation pipeline which generates native machine code is not affected.",
            "title": "High-level architecture"
        },
        {
            "location": "/architecture/#about-booting",
            "text": "In order for  asterius  to support non-trivial Haskell programs (that is, at least most things in  Prelude ), it needs to run the compilation process for  base  and its dependent packages. This process is known as \"booting\".  The  asterius  package provides an  ahc-boot  test suite which tests booting by compiling the wired-in packages provided by  ghc-toolkit  and using  ahc  to replace  ghc  when configuring. This is inspired by Joachim Breitner's  veggies .",
            "title": "About \"booting\""
        },
        {
            "location": "/webassembly/",
            "text": "WebAssembly as a Haskell compilation target\n\n\nThere are a few issues to address when compiling Cmm to WebAssembly.\n\n\nImplementing Haskell Stack/Heap\n\n\nThe Haskell runtime maintains a TSO(Thread State Object) for each Haskell thread, and each TSO contains a separate stack for the STG machine. The WebAssembly platform has its own \"stack\" concept though; the execution of WebAssembly is based on a stack machine model, where instructions consume operands on the stack and push new values onto it.\n\n\nWe use the linear memory to simulate Haskell stack/heap. Popping/pushing the Haskell stack only involves loading/storing on the linear memory. Heap allocation only involves bumping the heap pointer. Running out of space will trigger a WebAssembly trap, instead of doing GC.\n\n\nAll discussions in the documentation use the term \"stack\" for the Haskell stack, unless explicitly stated otherwise.\n\n\nImplementing STG machine registers\n\n\nThe Haskell runtime makes use of \"virtual registers\" like Sp, Hp or R1 to implement the STG machine. The NCG tries to map some of the virtual registers to real registers when generating assembly code. However, WebAssembly doesn't have language constructs that map to real registers, so all virtual registers are implemented as local variables of the interpreter function.\n\n\nHandling control flow\n\n\nWebAssembly currently enforces structured control flow, which prohibits arbitrary branching. Also, explicit tail calls are missing.\n\n\nThe Cmm control flow mainly involves two forms of branching: in-function or cross-function. Each function consists of a map from \nhoopl\n labels to basic blocks and an entry label. Branching happens at the end of each basic block.\n\n\nIn-function branching is relatively easier to handle. \nbinaryen\n provides a \"relooper\" which can recover WebAssembly instructions with structured control flow from a control-flow graph. For each \nCmmGraph\n we invoke the relooper to handle branching between basic blocks.\n\n\nCross-function branching (\nCmmCall\n) is tricky. WebAssembly lacks explicit tail calls, and the relooper can't be easily used in this case since there's a computed goto, and potential targets include all Cmm blocks involved in linking. There are multiple possible ways to handle this situation:\n\n\n\n\nCollect all Cmm blocks into one function, additionally add a \"dispatcher\" block. All \nCmmCall\ns save the callee to a register and branch to the \"dispatcher\" block, and the \"dispatcher\" uses \nbr_table\n or a binary decision tree to branch to the entry block of callee.\n\n\nOne WebAssembly function for one \nCmmProc\n, and upon \nCmmCall\n the function returns the function id of callee. A mini-interpreter function at the top level repeatedly invoke the functions using \ncall_indirect\n. This approach is actually used by the unregisterised mode of \nghc\n.\n\n\n\n\nWe're still investigating the best way. The first approach probably produces the fastest code, at the cost of no dynamic linking (not a scheduled feature anyway) and potential slowdown when linking large Haskell programs (unless an O(n) relooping algorithm is implemented).\n\n\nUpdate: for the first approach, using a long chain of nested blocks combined with a single \nbr_table\n seems not to scale. On my laptop \nbinaryen\n can't finish validation/serialization for a mere 10^6 blocks in a minute.\n\n\nHandling relocations\n\n\nWhen producing a WebAssembly binary, we need to map \nCLabel\ns to the precise linear memory locations for \nCmmStatics\n or the precise table ids for \nCmmProc\ns. They are unknown when compiling individual modules, so \nbinaryen\n is invoked only when linking, and during compiling we only convert \nCLabel\ns to some serializable representation.\n\n\nCurrently WebAssembly community has a \nproposal\n for linkable object format, and it's prototyped by \nlld\n. We'll probably turn to that format and use \nlld\n some day, but right now we'll simply stick to our own format for simplicity.\n\n\nThe word size story\n\n\nAlthough \nwasm64\n is scheduled, currently only \nwasm32\n is implemented. However, we are running 64-bit \nghc\n, and there are several places which need extra care:\n\n\n\n\nThe load/store instructions operate on 64-bit addresses, yet \nwasm32\n use \nuint32\n when indexing into the linear memory.\n\n\nThe \nCmmSwitch\n labels are 64-bit. \nCmmCondBranch\n also checks a 64-bit condition. \nbr_if\n/\nbr_table\n operates on \nuint32\n.\n\n\nOnly \ni32\n/\ni64\n is supported by \nwasm32\n value types, but in Cmm we also need arithmetic on 8-bit/16-bit integers.\n\n\n\n\nAs for booleans: there's no native boolean type in either WebAssembly or Cmm. As a convention we use \nuint32\n.\n\n\nPages and addresses\n\n\nThe WebAssembly linear memory has a hard-coded page size of 64KB. There are several places which operate in units of pages rather than raw bytes:\n\n\n\n\nCurrentMemory\n/\nGrowMemory\n\n\nMemory\n component of a \nModule",
            "title": "About WebAssembly"
        },
        {
            "location": "/webassembly/#webassembly-as-a-haskell-compilation-target",
            "text": "There are a few issues to address when compiling Cmm to WebAssembly.",
            "title": "WebAssembly as a Haskell compilation target"
        },
        {
            "location": "/webassembly/#implementing-haskell-stackheap",
            "text": "The Haskell runtime maintains a TSO(Thread State Object) for each Haskell thread, and each TSO contains a separate stack for the STG machine. The WebAssembly platform has its own \"stack\" concept though; the execution of WebAssembly is based on a stack machine model, where instructions consume operands on the stack and push new values onto it.  We use the linear memory to simulate Haskell stack/heap. Popping/pushing the Haskell stack only involves loading/storing on the linear memory. Heap allocation only involves bumping the heap pointer. Running out of space will trigger a WebAssembly trap, instead of doing GC.  All discussions in the documentation use the term \"stack\" for the Haskell stack, unless explicitly stated otherwise.",
            "title": "Implementing Haskell Stack/Heap"
        },
        {
            "location": "/webassembly/#implementing-stg-machine-registers",
            "text": "The Haskell runtime makes use of \"virtual registers\" like Sp, Hp or R1 to implement the STG machine. The NCG tries to map some of the virtual registers to real registers when generating assembly code. However, WebAssembly doesn't have language constructs that map to real registers, so all virtual registers are implemented as local variables of the interpreter function.",
            "title": "Implementing STG machine registers"
        },
        {
            "location": "/webassembly/#handling-control-flow",
            "text": "WebAssembly currently enforces structured control flow, which prohibits arbitrary branching. Also, explicit tail calls are missing.  The Cmm control flow mainly involves two forms of branching: in-function or cross-function. Each function consists of a map from  hoopl  labels to basic blocks and an entry label. Branching happens at the end of each basic block.  In-function branching is relatively easier to handle.  binaryen  provides a \"relooper\" which can recover WebAssembly instructions with structured control flow from a control-flow graph. For each  CmmGraph  we invoke the relooper to handle branching between basic blocks.  Cross-function branching ( CmmCall ) is tricky. WebAssembly lacks explicit tail calls, and the relooper can't be easily used in this case since there's a computed goto, and potential targets include all Cmm blocks involved in linking. There are multiple possible ways to handle this situation:   Collect all Cmm blocks into one function, additionally add a \"dispatcher\" block. All  CmmCall s save the callee to a register and branch to the \"dispatcher\" block, and the \"dispatcher\" uses  br_table  or a binary decision tree to branch to the entry block of callee.  One WebAssembly function for one  CmmProc , and upon  CmmCall  the function returns the function id of callee. A mini-interpreter function at the top level repeatedly invoke the functions using  call_indirect . This approach is actually used by the unregisterised mode of  ghc .   We're still investigating the best way. The first approach probably produces the fastest code, at the cost of no dynamic linking (not a scheduled feature anyway) and potential slowdown when linking large Haskell programs (unless an O(n) relooping algorithm is implemented).  Update: for the first approach, using a long chain of nested blocks combined with a single  br_table  seems not to scale. On my laptop  binaryen  can't finish validation/serialization for a mere 10^6 blocks in a minute.",
            "title": "Handling control flow"
        },
        {
            "location": "/webassembly/#handling-relocations",
            "text": "When producing a WebAssembly binary, we need to map  CLabel s to the precise linear memory locations for  CmmStatics  or the precise table ids for  CmmProc s. They are unknown when compiling individual modules, so  binaryen  is invoked only when linking, and during compiling we only convert  CLabel s to some serializable representation.  Currently WebAssembly community has a  proposal  for linkable object format, and it's prototyped by  lld . We'll probably turn to that format and use  lld  some day, but right now we'll simply stick to our own format for simplicity.",
            "title": "Handling relocations"
        },
        {
            "location": "/webassembly/#the-word-size-story",
            "text": "Although  wasm64  is scheduled, currently only  wasm32  is implemented. However, we are running 64-bit  ghc , and there are several places which need extra care:   The load/store instructions operate on 64-bit addresses, yet  wasm32  use  uint32  when indexing into the linear memory.  The  CmmSwitch  labels are 64-bit.  CmmCondBranch  also checks a 64-bit condition.  br_if / br_table  operates on  uint32 .  Only  i32 / i64  is supported by  wasm32  value types, but in Cmm we also need arithmetic on 8-bit/16-bit integers.   As for booleans: there's no native boolean type in either WebAssembly or Cmm. As a convention we use  uint32 .",
            "title": "The word size story"
        },
        {
            "location": "/webassembly/#pages-and-addresses",
            "text": "The WebAssembly linear memory has a hard-coded page size of 64KB. There are several places which operate in units of pages rather than raw bytes:   CurrentMemory / GrowMemory  Memory  component of a  Module",
            "title": "Pages and addresses"
        },
        {
            "location": "/roadmap/",
            "text": "This page maintains a list of milestones along with their planned features. Some notations:\n\n\n\n\nM0, M1, .. indicates Milestone 0, Milestone 1, etc. The numbers grow monotonically.\n\n\nP0, P1, .. incicates Priority 0, Priority 1, etc. The lesser the number, the more significant is the feature.\n\n\nA P0 feature blocks a milestone if it is not shipped.\n\n\nA P1 feature can delay a milestone if it can be shipped with a reasonable delay.\n\n\nA P2 feature can be re-scheduled or modified to prevent blocking a milestone.\n\n\n\n\nM1\n\n\nApproximate delivery time: Apr 15, 2018 (MISSED)\n\n\nThe purpose of M1 is to ship an MVP(Minimum Viable Product).\n\n\nP0 features\n\n\n\n\nCan compile a standalone Haskell executable involving simple pure computations plus a few \nIO\n routines like \nputStrLn\n. The output will be a linked WebAssembly module with HTML/JavaScript loader, and the effect can be demostrated via outputing to a browser console.\n\n\nIf involved with unsupported primops, foreign calls, etc, a compile-time error instead of a run-time error will be given.\n\n\nThe wasm rts allocates linear memory only once during startup, and only provides a bump allocator. No GC is implemented. A stack/heap overflow causes the runtime to exit immediately and report error in JavaScript.\n\n\n\n\nP1 features\n\n\n\n\nA separate \nbinaryen\n package to provide raw bindings to the \nbinaryen\n project.\n\n\nA separate \nwasm-toolkit\n package to provide a Haskellish IR wrapping \nbinaryen\n, also providing simple utilities like simulating tail-calls, linking multiple modules, eliminating dead code, etc.\n\n\n\n\nP2 features\n\n\n\n\nA test suite which uses Node.js/Headless Chrome to test the generated WebAssembly modules.\n\n\nA separate \ninline-javascript\n package to provide quasi-quoters for evaluating JavaScript embedded in Haskell, useful for the test suite.\n\n\nA build system based on nix/bazel instead of docker for developers on Linux/Mac.\n\n\nFix Windows support, set up AppVeyor for testing the project itself/building the custom ghc bindist required for the project.\n\n\n\n\nCurrent progress\n\n\nLast updated on: Apr 16, 2018\n\n\nRegarding P0 features\n\n\n\n\nAble to compile and serialize boot libs(\nghc-prim\n/\ninteger-simple\n/\nbase\n, along with \n.cmm\n files in \nrts\n). The current IR & object format is organized as simple K/V stores, with keys being marshaled Cmm symbols, which will be used as unique identifiers for relocation when linking.\n\n\nAble to generate \nbinaryen\n IR from pure Haskell programs which depend on only boot libs.\n\n\nThe linker panics about unimplemented C/Cmm routines in \nrts\n. They are all related to the storage manager, and to provide pure WebAssembly shims even with the no-GC scenario it takes much more time than anticipated.\n\n\n\n\nRegarding P1/P2 features\n\n\n\n\nCI workflows that supports building/testing \nasterius\n on Windows/Linux x64 are set up. The headless browser part is not up yet, since no runnable standalone wasm32 binaries are produced for now.\n\n\ninline-javascript\n is available.\n\n\n(Originally in M2) \nghc-toolkit\n is available and can be used by any Haskell-to-X compiler author.\n\n\n(Originally in M2) A static documentation \nsite\n is available. More introductory material for newcomers need to be written though.\n\n\n\n\nM2\n\n\nApproximate delivery time: Jun 30, 2018\n\n\nAt this point the project status changes from pre-alpha to alpha, meaning it's actually possible to make one or two useful gadgets out of this project.\n\n\nP0 features\n\n\n\n\nThe wasm rts performs GC. There will be a naive hand-written GC which prevents stack/heap overflow in the long run, but the GC pause may be quite noticable at this point.\n\n\nAn FFI mechanism, more feature-rich than the current WebAssembly import/export mechanism. It supports keeping handles of arbitrary JavaScript values in the wasm rts and invoking JavaScript functions with those values. Calling back from the JavaScript world is not supported yet.\n\n\n\n\nP1 features\n\n\n\n\nSupport more primops, preferrably everything in \nGHC.Prim\n but excluding the following parts (they are planned for milestones beyond M2):\n\n\nThreading\n\n\nWeak references\n\n\nStableName/StablePtr\n\n\nCompact regions\n\n\nSparks\n\n\nBytecode\n\n\nSIMD\n\n\nPrefetch\n\n\n\n\n\n\nMore real-world demos, since with FFI it's already possible to work with DOM API.\n\n\n\n\nP2 features\n\n\n\n\nA separate \nghc-toolkit\n package to provide a framework for compiling from Haskell to anything. Users will only need to be familiar with various GHC IR types, and don't need to bother with details like \nCabal\n integration, frontend plugins, booting, etc.\n\n\nIntegration with existing JavaScript ecosystem, possibly something like an \nnpm\n package or a \nwebpack\n plugin.\n\n\nA wiki for potential contributors.\n\n\nA blog post about yet another great Tweag I/O project.",
            "title": "Project roadmap"
        },
        {
            "location": "/roadmap/#m1",
            "text": "Approximate delivery time: Apr 15, 2018 (MISSED)  The purpose of M1 is to ship an MVP(Minimum Viable Product).",
            "title": "M1"
        },
        {
            "location": "/roadmap/#p0-features",
            "text": "Can compile a standalone Haskell executable involving simple pure computations plus a few  IO  routines like  putStrLn . The output will be a linked WebAssembly module with HTML/JavaScript loader, and the effect can be demostrated via outputing to a browser console.  If involved with unsupported primops, foreign calls, etc, a compile-time error instead of a run-time error will be given.  The wasm rts allocates linear memory only once during startup, and only provides a bump allocator. No GC is implemented. A stack/heap overflow causes the runtime to exit immediately and report error in JavaScript.",
            "title": "P0 features"
        },
        {
            "location": "/roadmap/#p1-features",
            "text": "A separate  binaryen  package to provide raw bindings to the  binaryen  project.  A separate  wasm-toolkit  package to provide a Haskellish IR wrapping  binaryen , also providing simple utilities like simulating tail-calls, linking multiple modules, eliminating dead code, etc.",
            "title": "P1 features"
        },
        {
            "location": "/roadmap/#p2-features",
            "text": "A test suite which uses Node.js/Headless Chrome to test the generated WebAssembly modules.  A separate  inline-javascript  package to provide quasi-quoters for evaluating JavaScript embedded in Haskell, useful for the test suite.  A build system based on nix/bazel instead of docker for developers on Linux/Mac.  Fix Windows support, set up AppVeyor for testing the project itself/building the custom ghc bindist required for the project.",
            "title": "P2 features"
        },
        {
            "location": "/roadmap/#current-progress",
            "text": "Last updated on: Apr 16, 2018",
            "title": "Current progress"
        },
        {
            "location": "/roadmap/#regarding-p0-features",
            "text": "Able to compile and serialize boot libs( ghc-prim / integer-simple / base , along with  .cmm  files in  rts ). The current IR & object format is organized as simple K/V stores, with keys being marshaled Cmm symbols, which will be used as unique identifiers for relocation when linking.  Able to generate  binaryen  IR from pure Haskell programs which depend on only boot libs.  The linker panics about unimplemented C/Cmm routines in  rts . They are all related to the storage manager, and to provide pure WebAssembly shims even with the no-GC scenario it takes much more time than anticipated.",
            "title": "Regarding P0 features"
        },
        {
            "location": "/roadmap/#regarding-p1p2-features",
            "text": "CI workflows that supports building/testing  asterius  on Windows/Linux x64 are set up. The headless browser part is not up yet, since no runnable standalone wasm32 binaries are produced for now.  inline-javascript  is available.  (Originally in M2)  ghc-toolkit  is available and can be used by any Haskell-to-X compiler author.  (Originally in M2) A static documentation  site  is available. More introductory material for newcomers need to be written though.",
            "title": "Regarding P1/P2 features"
        },
        {
            "location": "/roadmap/#m2",
            "text": "Approximate delivery time: Jun 30, 2018  At this point the project status changes from pre-alpha to alpha, meaning it's actually possible to make one or two useful gadgets out of this project.",
            "title": "M2"
        },
        {
            "location": "/roadmap/#p0-features_1",
            "text": "The wasm rts performs GC. There will be a naive hand-written GC which prevents stack/heap overflow in the long run, but the GC pause may be quite noticable at this point.  An FFI mechanism, more feature-rich than the current WebAssembly import/export mechanism. It supports keeping handles of arbitrary JavaScript values in the wasm rts and invoking JavaScript functions with those values. Calling back from the JavaScript world is not supported yet.",
            "title": "P0 features"
        },
        {
            "location": "/roadmap/#p1-features_1",
            "text": "Support more primops, preferrably everything in  GHC.Prim  but excluding the following parts (they are planned for milestones beyond M2):  Threading  Weak references  StableName/StablePtr  Compact regions  Sparks  Bytecode  SIMD  Prefetch    More real-world demos, since with FFI it's already possible to work with DOM API.",
            "title": "P1 features"
        },
        {
            "location": "/roadmap/#p2-features_1",
            "text": "A separate  ghc-toolkit  package to provide a framework for compiling from Haskell to anything. Users will only need to be familiar with various GHC IR types, and don't need to bother with details like  Cabal  integration, frontend plugins, booting, etc.  Integration with existing JavaScript ecosystem, possibly something like an  npm  package or a  webpack  plugin.  A wiki for potential contributors.  A blog post about yet another great Tweag I/O project.",
            "title": "P2 features"
        },
        {
            "location": "/readings/",
            "text": "Reading list\n\n\nHere is a brief list of relevant readings about GHC internals and WebAssembly suited for newcomers.\n\n\n\n\nGHC documentation regarding the GHC API\n: a nice reading for anyone looking forward to using the GHC API.\n\n\nGHC commentary\n: a wiki containing lots of additional knowledge regarding GHC's implementation. Keep in mind some content is out-dated though. Some useful entries regarding this project:\n\n\nBuilding guide\n. A tl;dr for this section is our CI scripts.\n\n\nOverview of pipeline\n: we use the Hooks mechanism (specifically, \nrunPhaseHook\n) to replace the default pipeline with our own, to enable manipulation of in-memory IRs.\n\n\nHow STG works\n: a nice tutorial containing several examples of compiled examples, illustrating how the generated code works under the hood.\n\n\nThe Cmm types\n: it's outdated and the types don't exactly match the GHC codebase now, but the explanations still shed some light on how the current Cmm types work.\n\n\nThe runtime system\n: content regarding the runtime system.\n\n\n\n\n\n\nUnderstanding the Stack\n: A blog post explaining how generated code works at the assembly level. Also, its sequel \nUnderstanding the RealWorld\n\n\nThe WebAssembly spec\n: a useful reference regarding what's already present in WebAssembly.\n\n\nThe \nbinaryen\n C API\n: \nbinaryen\n handles WebAssembly code generation. There are a few differences regarding \nbinaryen\n AST and WebAssembly AST, the most notable ones:\n\n\nbinaryen\n uses a recursive \nBinaryenExpression\n which is side-effectful. The original WebAssembly standard instead uses a stack-based model and manipulates the operand stack with instructions.\n\n\nbinaryen\n contains a \"Relooper\" which can recover high-level structured control flow from a CFG. However the relooper doesn't handle jumping to unknown labels (aka computed goto), so we don't use it to handle tail calls.\n\n\n\n\n\n\n\n\nThe following entries are papers which consume much more time to read, but still quite useful for newcomers:\n\n\n\n\nMaking a fast curry: push/enter vs. eval/apply for higher-order languages\n: A thorough explanation of what is STG and how it is implemented (via two different groups of rewrite rules, also with real benchmarks)\n\n\nThe STG runtime system (revised)\n: Includes some details on the runtime system and worth a read. It's a myth why it's not merged with the commentary though. Install a TeX distribution like TeX Live or use a service like Overleaf to compile the \n.tex\n file to \n.pdf\n before reading.\n\n\nThe GHC storage manager\n: Similar to above.\n\n\nBringing the Web up to Speed with WebAssembly\n: The PLDI'17 paper about WebAssembly. Contains overview of WebAssembly design rationales and rules of small-step operational semantics.\n\n\n\n\nFinally, the GHC codebase itself is also a must-read, but since it's huge we only need to check relevant parts when unsure about its behavior. Tips on reading GHC code:\n\n\n\n\nThere are a lot of insightful and up-to-date comments which all begin with \"Notes on xxx\". It's a pity the notes are neither collected into the sphinx-generated documentation or into the haddock docs of GHC API.\n\n\nWhen writing \nbuild.mk\n for compiling GHC, add \nHADDOCK_DOCS = YES\n to ensure building haddock docs of GHC API, and \nEXTRA_HADDOCK_OPTS += --quickjump --hyperlinked-source\n to enable symbol hyperlinks in the source pages. This will save you tons of time from \ngrep\ning the ghc codebase.\n\n\ngrep\ning is still unavoidable in some cases, since there's a lot of CPP involved and they aren't well handled by haddock.",
            "title": "Reading list"
        },
        {
            "location": "/readings/#reading-list",
            "text": "Here is a brief list of relevant readings about GHC internals and WebAssembly suited for newcomers.   GHC documentation regarding the GHC API : a nice reading for anyone looking forward to using the GHC API.  GHC commentary : a wiki containing lots of additional knowledge regarding GHC's implementation. Keep in mind some content is out-dated though. Some useful entries regarding this project:  Building guide . A tl;dr for this section is our CI scripts.  Overview of pipeline : we use the Hooks mechanism (specifically,  runPhaseHook ) to replace the default pipeline with our own, to enable manipulation of in-memory IRs.  How STG works : a nice tutorial containing several examples of compiled examples, illustrating how the generated code works under the hood.  The Cmm types : it's outdated and the types don't exactly match the GHC codebase now, but the explanations still shed some light on how the current Cmm types work.  The runtime system : content regarding the runtime system.    Understanding the Stack : A blog post explaining how generated code works at the assembly level. Also, its sequel  Understanding the RealWorld  The WebAssembly spec : a useful reference regarding what's already present in WebAssembly.  The  binaryen  C API :  binaryen  handles WebAssembly code generation. There are a few differences regarding  binaryen  AST and WebAssembly AST, the most notable ones:  binaryen  uses a recursive  BinaryenExpression  which is side-effectful. The original WebAssembly standard instead uses a stack-based model and manipulates the operand stack with instructions.  binaryen  contains a \"Relooper\" which can recover high-level structured control flow from a CFG. However the relooper doesn't handle jumping to unknown labels (aka computed goto), so we don't use it to handle tail calls.     The following entries are papers which consume much more time to read, but still quite useful for newcomers:   Making a fast curry: push/enter vs. eval/apply for higher-order languages : A thorough explanation of what is STG and how it is implemented (via two different groups of rewrite rules, also with real benchmarks)  The STG runtime system (revised) : Includes some details on the runtime system and worth a read. It's a myth why it's not merged with the commentary though. Install a TeX distribution like TeX Live or use a service like Overleaf to compile the  .tex  file to  .pdf  before reading.  The GHC storage manager : Similar to above.  Bringing the Web up to Speed with WebAssembly : The PLDI'17 paper about WebAssembly. Contains overview of WebAssembly design rationales and rules of small-step operational semantics.   Finally, the GHC codebase itself is also a must-read, but since it's huge we only need to check relevant parts when unsure about its behavior. Tips on reading GHC code:   There are a lot of insightful and up-to-date comments which all begin with \"Notes on xxx\". It's a pity the notes are neither collected into the sphinx-generated documentation or into the haddock docs of GHC API.  When writing  build.mk  for compiling GHC, add  HADDOCK_DOCS = YES  to ensure building haddock docs of GHC API, and  EXTRA_HADDOCK_OPTS += --quickjump --hyperlinked-source  to enable symbol hyperlinks in the source pages. This will save you tons of time from  grep ing the ghc codebase.  grep ing is still unavoidable in some cases, since there's a lot of CPP involved and they aren't well handled by haddock.",
            "title": "Reading list"
        }
    ]
}